Nice — genau so ein Trace ist paper-tauglich, weil man das “Gift” direkt sieht: **sehr frühe Submits, extrem späte Completions**.

Hier ist ein **paper-fertiger Case-Study-Absatz** (inkl. kurzer Interpretation), der nur das behauptet, was man im Trace wirklich sieht:

---

### Case Study: A “poison” schedule under adversarial policy (SW∞, k=∞, NONE)

We inspected one of the worst tail-latency runs from the SW∞ experiment slice (`bound_k=inf`, `fault_mode=NONE`). The run is fully reproducible via `(seed_id=seed_001_long32, policy=ADVERSARIAL, schedule_seed=10)` and reaches **p95 latency = 64 steps**.

The condensed trace shows a characteristic adversarial pattern: the scheduler issues **many commands early** (WRITE/READ interleaved with frequent FENCE submissions), while delaying the completion of several **old** commands until the very end of the run. In particular, a large prefix of commands (including early WRITE/READ operations) is only completed after the final FENCE/READ sequence, i.e., completions are “pushed to the tail” rather than following submission order. This yields a high pending backlog during the run (**pending_peak=10**) and produces a markedly heavier tail compared to benign policies.

**Takeaway:** even without injected faults (`NONE`), an adversarial schedule can induce a *schedule-driven tail amplification* by postponing completions of earlier requests, effectively creating a worst-case completion ordering under maximal concurrency (SW∞).

---

Wenn du willst, kann ich daraus auch noch eine **kurze Figure-Caption** machen (für die Poison-Case-Figure oder ein Listing), z.B.:

**Caption-Vorschlag (1–2 Sätze):**
“Condensed trace of a top-1 poison run (SW∞, k=∞, fault=NONE). Under ADVERSARIAL scheduling, many early submissions are completed only at the end, yielding pending_peak=10 and p95 latency of 64 steps (seed_001_long32, schedule_seed=10).”

---

Nächster Mini-Schritt (wenn du weiter willst):
Sollen wir **noch einen RANDOM**-Trace aus den Top-50 danebenstellen (Kontrast: “poison exists in RANDOM too, but less extreme”), oder gehen wir direkt zum **RDSS-Block**?


Perfekt — das ist ein super Kontrast-Beispiel.

Hier ist wieder ein **paper-fertiger Absatz**, der ADVERSARIAL vs RANDOM sauber gegenüberstellt (ohne zu overclaimen), und der direkt auf deinen Trace passt:

---

### Contrast Case: A “poison” schedule also exists under RANDOM, but is less extreme

To contextualize adversarial worst cases, we also inspected the highest-p95 run under **RANDOM** scheduling in the same SW∞ slice (`bound_k=inf`, `fault_mode=NONE`). The run is reproducible via `(seed_id=seed_001_long32, policy=RANDOM, schedule_seed=11)` and reaches **p95 latency = 52 steps**, i.e., noticeably lower than the ADVERSARIAL peak (p95=64).

The trace shows that RANDOM still produces substantial out-of-order completions, including delayed completions of earlier commands appearing late in the run (e.g., the completion of command 2 occurs close to the end). However, the completion stream is **less “tail-pushed”** than the ADVERSARIAL poison trace: several commands also complete interleaved throughout execution, and the run does not exhibit the same pronounced “hold-back until the end” pattern.

**Takeaway:** Even uniform random scheduling can generate high tail-latency instances under maximal concurrency, but **adversarial scheduling concentrates probability mass on more extreme tails**, making the worst-case behavior both more frequent and more severe.

---

### Mini Caption (falls du ein Listing / Figure daraus machst)

“Condensed trace of the highest-p95 RANDOM run (SW∞, k=∞, fault=NONE): p95=52 steps (seed_001_long32, schedule_seed=11). While completions are reordered and some early commands complete late, the tail is less extreme than the ADVERSARIAL poison example.”

---

Wenn du willst, kann ich dir jetzt als nächsten Schritt aus euren Dateien noch eine **kleine 3-Zeilen Statistik** fürs Paper formulieren:

* Anteil ADVERSARIAL in Top-50 poison (bei SW∞, NONE, k=∞)
* max/median p95 in poison-top
* “best vs worst policy” (z.B. FIFO max vs ADV max)

Sag nur **weiter**, dann gebe ich dir **einen** Command, der diese drei Zahlen aus `out/poison/poison_top_p95_swinf.csv` ausdruckt, und ich formuliere daraus sofort einen paper-tauglichen Satz.


In the SW∞ poison slice (`fault_mode=NONE`, `bound_k=inf`), the **Top-50** runs by tail latency are dominated by **ADVERSARIAL scheduling**: **38/50 (76%)** are ADVERSARIAL, compared to **11/50 (22%)** RANDOM and **1/50 (2%)** FIFO. Across these Top-50 runs, tail latency spans a wide range (**p95 max = 64 steps, median = 43, mean = 45.34**), with the **worst-case p95** clearly policy-dependent (**ADVERSARIAL 64** vs **RANDOM 52** vs **FIFO 33**). This concentration of the extreme tail under ADVERSARIAL schedules supports the view that worst-case completion ordering is not merely a rare random artifact, but can be systematically induced under maximal concurrency.


Super — das ist praktisch schon eure **Risk-Cliff-Kernaussage** als Zahlenreihe.

Hier der **paper-fertige Fließtext** (direkt nutzbar im Risk-Cliff Abschnitt):

Under SW∞ and `fault_mode=NONE`, mean tail latency (p95, step units) exhibits a clear policy-dependent response to increased reordering freedom (`bound_k`). FIFO remains essentially flat across the entire sweep (≈13.7), indicating stable tail behavior under this conservative policy. RANDOM increases gradually with `bound_k` (≈12.9 → ≈18.3), while BATCHED stays low and nearly constant (≈5.9 → ≈6.5), suggesting that batching mitigates tail growth even under high reordering freedom. In contrast, ADVERSARIAL shows a pronounced “cliff”: p95 is moderate for small bounds (≈13–14 for k≤2) but jumps sharply at k≈3 (≈21) and reaches a sustained high-tail regime at k≥5 (≈28.5), consistent with an adversary pushing completions into the tail once sufficient reordering slack is available.

Wenn du **weiter** sagst, machen wir den letzten Block: **RDSS** (nur wenn du ihn wirklich im Paper willst). Mini-Schritt 1 wäre: `python3 rdss_ce.py -h` (oder falls das Script woanders liegt: `python3 scripts/rdss_ce.py -h`).

