Generality check (second workload seed). To assess whether the observed risk structure is specific to a single workload instance, we repeated the SW∞ experiment with a second workload seed while keeping the experiment matrix fixed (policies, reordering bounds bound_k, fault modes, and schedule-seed pool). The absolute tail-latency levels differ between the two seeds, which is expected given different workload characteristics and concurrency pressure. Importantly, however, the qualitative policy-dependent response to increasing reordering freedom remains consistent: FIFO stays essentially flat across bound_k, RANDOM increases moderately and then saturates, BATCHED remains consistently low, and ADVERSARIAL yields the strongest tail amplification. We additionally observe that the transition into the high-tail regime can shift across workloads (i.e., the “cliff” occurs at different bound_k), while the relative vulnerability ordering of policies remains unchanged. Overall, this indicates that the risk-cliff phenomenon is not an artifact of a single seed, but reflects a structural sensitivity of tail behavior to adversarial reordering under high concurrency.

## Option B) Second-seed generality check (SW∞)

### Goal
Repeat the SW∞ experiment with a second workload seed (`seed_002.json`) while keeping policies, bounds, fault modes, and the schedule-seed pool unchanged. Then compare the qualitative p95-vs-k structure for `fault_mode=NONE`.

### 1) Create a seed2 config
python3 -c 'import yaml; p="configs/main.yaml"; o="configs/main_seed2.yaml"; cfg=yaml.safe_load(open(p,"r",encoding="utf-8")); cfg["seeds"]=["seeds/seed_002.json"]; yaml.safe_dump(cfg, open(o,"w",encoding="utf-8"), sort_keys=False); print("[ok] wrote", o)'

### 2) Run SW∞ matrix (seed2) → logs
rm -rf out/logs_swinf_seed2; mkdir -p out/logs_swinf_seed2; ./target/release/nvme-lite-oracle run-matrix --config configs/main_seed2.yaml --out-dir out/logs_swinf_seed2 --submit-window inf

### 3) Parse logs → run-level CSV
mkdir -p out/csv; python3 scripts/01_parse_check.py --logs out/logs_swinf_seed2 --out out/csv/results_swinf_seed2.csv

### 4) (Optional) Aggregate seed2 results
python3 scripts/02_aggregate.py --in out/csv/results_swinf_seed2.csv --out out/csv/summary_swinf_seed2.csv

### 5) Save Seed1 vs Seed2 compare (fault=NONE): mean p95 by policy × bound_k
mkdir -p out/tab && python3 -c 'import csv; bounds=["0","1","2","3","5","10","inf"]; policies=["FIFO","RANDOM","BATCHED","ADVERSARIAL"];
def mean_p95(path):
 d={}; n={}
 for r in csv.DictReader(open(path,newline="",encoding="utf-8")):
  if r.get("fault_mode")!="NONE":
   continue
  pol=r.get("policy"); bk=r.get("bound_k"); x=r.get("p95_latency_step","")
  if not pol or not bk or x=="":
   continue
  try: v=float(x)
  except:
   continue
  k=(pol,bk); d[k]=d.get(k,0.0)+v; n[k]=n.get(k,0)+1
 out={}
 for pol in policies:
  out[pol]={}
  for bk in bounds:
   k=(pol,bk)
   out[pol][bk]=(d[k]/n[k]) if k in n and n[k]>0 else float("nan")
 return out
a=mean_p95("out/csv/results_swinf.csv")
b=mean_p95("out/csv/results_swinf_seed2.csv")
lines=[]
lines.append("[seed1] mean p95_latency_step, fault=NONE")
for pol in policies:
 lines.append(pol+" "+" ".join(f"{a[pol][bk]:.2f}" if a[pol][bk]==a[pol][bk] else "nan" for bk in bounds))
lines.append("[seed2] mean p95_latency_step, fault=NONE")
for pol in policies:
 lines.append(pol+" "+" ".join(f"{b[pol][bk]:.2f}" if b[pol][bk]==b[pol][bk] else "nan" for bk in bounds))
open("out/tab/seed_compare_p95_none.txt","w",encoding="utf-8").write("\\n".join(lines)+"\\n")
print("[ok] wrote out/tab/seed_compare_p95_none.txt")'

### 6) Copy Option-B artifacts into a single folder
mkdir -p out/artifacts/optionB_seed2/{configs,csv,tab} && cp -a configs/main_seed2.yaml out/artifacts/optionB_seed2/configs/ && cp -a out/csv/results_swinf_seed2.csv out/csv/summary_swinf_seed2.csv out/artifacts/optionB_seed2/csv/ && cp -a out/tab/seed_compare_p95_none.txt out/artifacts/optionB_seed2/tab/
